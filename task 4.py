# -*- coding: utf-8 -*-
"""
Взгляните на показанный ниже код, в котором используется цикл while и флаг found
для поиска в списке степеней 2 значения 2, вовзевденной в пятую степень

@author: workk
"""
'''
Код явно написан с использование альетрнативной логики.
Попоробуйте оптимизировать код c использованием рекомендаций, они являются необезатальными, но помогут понять основные ошибки.
а) Сначала перепишите код с конструкцией else цикла while, чтобы избавиться от флага found и финального оператора if.
б) Затем перепишите код для использования цикла for с конструкцией else, чтобы избавиться от явной логики индексации 
списка. (Подсказка: для получения индекса элемента применяйте списковый метод index — L. index (X)
возвращает смещение первого элемента X в списке L.)
в) Далее полностью устраните цикл, переписав код с использованием простого выражения с операцией членства in. 
(За дополнительными сведениями обращайтесь в главу 8 или наберите для тестирования 2 in [1,2,3].)
г) Наконец примените цикл for и списковый метод append для генерации списка степеней 2 (L) вместо 
жесткого кодирования спискового литерала.
Ниже приведены более глубокие рассуждения.
д) Как вы думаете, улучшит ли производительность перенос выражения 2 ** X
за пределы циклов? Каким образом вы представили бы это в коде?
е)  Python содержит инструмент тар (функция, список), который также способен генерировать 
список степеней 2:. Каким образом можно его задать? 
'''

# Дано
L = [1, 2, 4, 8, 16, 32, 64]
X = 5
found = False
i = 0
while not found and i < len(L):
    if 2 ** X == L[i]:
        found = True
    else:
        i = i + 1

if found:
    print('at index', i)
else:
    print(X, 'not found')


# Решение:
# а)
L = [1, 2, 4, 8, 16, 32, 64]
X = 5
i = 0

while i < len(L):
    if 2 ** X == L[i]:
        print('at index', i)
        break
    i += 1
else:
    print(X, 'not found')


# б)
L = [1, 2, 4, 8, 16, 32, 64]
X = 5

for element in L:
    if 2 ** X == element:
        print('at index', L.index(element))
        break
else:
    print(X, 'not found')


# в)
L = [1, 2, 4, 8, 16, 32, 64]
X = 5

if 2 ** X in L:
    print('at index', L.index(2 ** X))
else:
    print(X, 'not found')


# г)
X = 5
L = []
for i in range(7):
    L.append(2 ** i)

if 2 ** X in L:
    print('at index', L.index(2 ** X))
else:
    print(X, 'not found')


# д) улучшит производительность, тк будет вычислено один раз, а не на каждой итерации цикла (ниже пример с циклом)
L = [1, 2, 4, 8, 16, 32, 64]
X = 5
pow_of_2 = 2 ** X

for element in L:
    if pow_of_2 == element:
        print('at index', L.index(element))
        break
else:
    print(X, 'not found')


# е) создадим список из степеней двойки
n = 7
L = [2 ** i for i in range(n)]
print(L)


